const express = require('express')
const db = require('./db');
const app = express()
var bodyParser = require('body-parser')

// VARIABLES
const USERNAME_MIN_LENGTH = 3
const USERNAME_MAX_LENGTH = 9
const MIN_PASSWORD_LENGTH = 3

const CONTENT_MIN_LENGTH = 3
const CONTENT_MAX_LENGTH = 500

// JSON WEB TOKEN GENERATED BY jwt.io
const ACCESS_TOKEN_SECRET = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9';
const ID_TOKEN_SECRET = 'SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';

// CORS
app.use(function (request, response, next) {

    response.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE")
    if (request.header("Access-Control-Request-Headers")) {
        response.setHeader(
            "Access-Control-Allow-Headers",
            request.header("Access-Control-Request-Headers")
        )
    }
    response.setHeader("Access-Control-Expose-Headers", "Location")

    next()

})

app.use(bodyParser.json());

// GET ALL LOGS
app.get("/log", function (request, response) {

    if (request.query.logId) {

        const logId = request.query.logId

        db.getLogById(logId, function (errors, log) {
            if (errors.length == 0) {
                response.status(200).json(log)
            } else {
                response.status(500).end()
            }
        })

    } else {

        db.getAllLog(function (errors, log) {
            if (errors.length == 0) {
                response.status(200).json(log)
            } else {
                response.status(500).end()
            }
        })

    }

})
//GET SINGLE LOG 
app.get("/log/:id", function (request, response) {

    const id = request.params.id

    db.getLogById(id, function (errors, log) {
        if (errors.length == 0) {
            if (log) {
                response.status(200).json(log)
            } else {
                response.status(404).end()
            }
        } else {
            response.status(500).end()
        }
    })

})
// GET ALL EMOTIONS
app.get("/emotion", function (request, response) {

    if (request.query.emotionId) {

        const logId = request.query.emotionId

        db.getEmotionById(emotionId, function (errors, emotion) {
            if (errors.length == 0) {
                response.status(200).json(log)
            } else {
                response.status(500).end()
            }
        })

    } else {

        db.getAllEmotion(function (errors, emotion) {
            if (errors.length == 0) {
                response.status(200).json(log)
            } else {
                response.status(500).end()
            }
        })

    }

})
//GET SINGLE EMOTION 
app.get("/emotion/:id", function (request, response) {

    const id = request.params.id

    db.getEmotionById(id, function (errors, log) {
        if (errors.length == 0) {
            if (log) {
                response.status(200).json(log)
            } else {
                response.status(404).end()
            }
        } else {
            response.status(500).end()
        }
    })

})

//CREATE USER ACCOUNT
app.post("/user", function (request, response) {

    const user = request.body

    // Check that the account contains all expected properties.
    const userTypes = {
        username: String,
        password: String
    }

    if (!hasTypes(user, userTypes)) {
        response.status(422).end()
        return
    }

    // Validate the account.
    const validationErrors = []

    if (user.username.length < USERNAME_MIN_LENGTH) {
        validationErrors.push("usernameTooShort")
    } else if (USERNAME_MAX_LENGTH < user.username.length) {
        validationErrors.push("usernameTooLong")
    }

    if (user.password.length < MIN_PASSWORD_LENGTH) {
        validationErrors.push("passwordTooShort")
    }

    if (0 < validationErrors.length) {
        response.status(400).json(validationErrors)
        return
    }

    // CREATE USER ACCOUNT
    db.createUser(user, function (errors, id) {
        if (errors.length == 0) {
            response.setHeader("Location", "/user/" + id)
            response.status(201).end()
        } else if (errors.includes("usernameTaken")) {
            response.status(400).json(errors)
        } else {
            response.status(500).end()
        }
    })

})

//GET SINGLE USER
app.get("/user/:id", function (request, response) {

    const id = request.params.id

    db.getAccountById(id, function (errors, user) {
        if (errors.length == 0) {
            if (user) {
                delete user.password //FOR SECURITY
                response.status(200).json(user)
            } else {
                response.status(404).end()
            }
        } else {
            response.status(500).end()
        }
    })
})

// GET TOKEN RESOURCES
app.post("/tokens", function (request, response) {

    const grantInfo = request.body

    // CHECK GRANT INTO PROPERTIES
    const grantInfoTypes = {
        grant_type: String,
        username: String,
        password: String
    }

    if (!hasTypes(grantInfo, grantInfoTypes)) {
        response.status(400).json({ error: "invalid_request" })
        return
    }

    // CHECK GRANT TYPE SUPPORTED
    // ACCESS TOKEN RESPONSE OAUTH 2.0
    if (grantInfo.grant_type != "password") {
        response.status(400).json({ error: "unsupported_grant_type" })
        return
    }
    db.getUserByUsername(grantInfo.username, function (errors, user) {
        if (errors.includes("databaseError")) {
            response.status(500).end()
        } else if (!user) {
            response.status(400).json({ error: "invalid_client" })
        } else if (user.password != grantInfo.password) {
            response.status(400).json({ error: "invalid_client" })
        } else {

            // SEND BACK ACCESS TOKEN AND ID TOKEN
            // INSTALL JSON WEB TOKEN
            const accessToken = jwt.sign({
                userId: user.id
            }, ACCESS_TOKEN_SECRET)

            // ID TOKEN CONTAIN INFO ABOUT WHO THE USER IS
            // openid.net
            const idToken = jwt.sign({
                sub: user.id,
                preferred_username: user.username
            }, ID_TOKEN_SECRET)

            // WHEN THE USER LOG IN SEND BOTH ACCESS AND ID TOKEN
            response.status(200).json({
                token_type: "Bearer",
                access_token: accessToken,
                id_token: idToken
            })
        }
    })
})

//CREATE NEW LOG
app.post("/log", function (request, response) {

    const log = request.body

    // EXTRACT INFO FROM ACCESS TOKEN
    var payload = null;

    try {
        //PASS AUTHORIZATION HEADER
        const authorizationHeader = request.get('Authorization')
        const accessToken = authorizationHeader.substr('Bearer'.length)

        var payload = jwt.verify(accessToken, ACCESS_TOKEN_SECRET);
    } catch (e) {}

    const logTypes = {
        Id: Number,
        date: Number,
        content: String,
        userId: Number,
        emotionId: Number
    }

    if (!hasTypes(log, logTypes)) {
        response.status(422).end()
        return
    }

    // AUTHORIZATION OF LOG CREATION
    const userId = request.userId
    if (!userId) {
        response.status(401).json(["notAuthenticated"])
        return
    } else if (log.userId != userId) {
        // NOT CREATOR OF LOG
        response.status(401).json(["notAuthorized"])
        return
    }

    // IF STATEMENT TO SEE IF IT IS AUTHORIZED TO SEND REQUEST
    if(payload == null || payload.userId != user.id){
        response.status(401).json(["notAuthorized"])
    }

    // VALIDATION OF NEW LOG
    const validationErrors = []

    if (log.content.length < CONTENT_MIN_LENGTH) {
        validationErrors.push("ContentTooShort")
    } else if (CONTENT_MAX_LENGTH < log.content.length) {
        validationErrors.push("ContentTooLong")
    }

    if (log.date < Date.now()) {
        validationErrors.push("DateTooEarly")
    }

    if (0 < validationErrors.length) {
        response.status(400).json(validationErrors)
        return
    }

    // CREATE LOG
    db.createLog(log, function (errors, id) {
        if (errors.length == 0) {
            response.setHeader("Location", "/log/" + id)
            response.status(201).end()
        } else if (errors.includes("UserNotFound")) {
            response.status(400).json(errors)
        } else {
            response.status(500).end()
        }
    })

})

//UPDATE LOG
app.put("/log/:id", function (request, response) {

    const id = request.params.id
    const updatedLog = request.body

    const logTypes = {
        id: Number,
        date: Number,
        content: String,
        userId: Number,
        emotionId: Number
    }

    if (!hasTypes(updatedLog, logTypes)) {
        response.status(422).end()
        return
    }

    db.getLogById(id, function (errors, oldLog) {

        if (0 < errors.length) {
            response.status(500).end()
            return
        } else if (!oldLog) {
            response.status(404).end()
            return
        }

        // CHECK AUTHENTICATION
        const userId = request.userId
        if (!userId) {
            // NOT AUTHENTICATED
            response.status(401).json(["notAuthenticated"])
            return
        } else if (oldLog.userId != userId) {
            // NOT CREATOR OF LOG
            response.status(401).json(["notAuthorized"])
            return
        } else if (updatedLog.userId != userId) {
            // NOT AUTHENTICATED
            response.status(401).json(["notAuthorized"])
            return
        }

        // VALIDATION OF LOG
        const validationErrors = []

        if (oldLog.id != updatedLog.id) {
            validationErrors.push("idChanged")
        }

        if (oldLog.date < Date.now()) {
            validationErrors.push("started")
            response.status(400).json(errors)
            return
        }

        if (oldLog.accountId != updatedLog.userId) {
            validationErrors.push("userIdChanged")
        }

        if (updatedLog.content.length < CONTENT_MIN_LENGTH) {
            validationErrors.push("contentTooShort")
        } else if (CONTENT_MAX_LENGTH < updatedLog.content.length) {
            validationErrors.push("contentTooLong")
        }

        if (updatedLog.date < Date.now()) {
            validationErrors.push("startTimeTooEarly")
        }

        if (0 < validationErrors.length) {
            response.status(400).json(validationErrors)
            return
        }

        // UPDATE LOG
        db.updateLogById(id, updatedLog, function (errors, didExist) {
            if (errors.length == 0) {
                if (didExist) {
                    response.status(204).end()
                } else {
                    response.status(404).end()
                }
            } else if (errors.includes("invalidUserId")) {
                response.status(400).json(errors)
            } else {
                response.status(500).end()
            }
        })
    })
})

//DELETE LOG
app.delete("/log/:id", function (request, response) {

    const id = request.params.id

    db.getLogById(id, function (errors, log) {

        if (0 < errors.length) {
            response.status(500).end()
            return
        } else if (!log) {
            response.status(404).end()
            return
        }

        // CHECK AUTHENTICATION
        const userId = request.userId
        if (!userId) {
            // NOT AUTHENTICATED
            response.status(401).json(["notAuthenticated"])
            return
        } else if (log.userId != userId) {
            // NOT CREATOR OF LOG
            response.status(401).json(["notAuthorized"])
            return
        }

        // DELETE LOG
        db.deleteLogById(id, function (errors, didExist) {
            if (errors.length == 0) {
                if (didExist) {
                    response.status(204).end()
                } else {
                    response.status(404).end()
                }
            } else {
                response.status(500).end()
            }
        })

    })

})

// TEST CODE
app.get("/", function (request, response) {
    response.send("Hello, World")
})


app.listen(3000)